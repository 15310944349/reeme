--@type:doc
--name response.view
--title 模板

--segment 这里的模板指的是HTML模板，用于解析后输出HTML内容到前端。本框架所带的模板比较独树一织，下面将逐一说明。

--segment 模板的所有指令都是以'{'符号开头，{后面可以有以下字符用于表示不同的功能：
--list %，即{% 代码 }，用于直接书写Lua代码，可长可短亦可以多行
--list =，即{=表达式}，用于编写一个表达式，该表达式必须要有一个可以计算出来的值，所以这个表达式可以是一个值，也可以是一个函数，也可以是更复杂的单行代码
--list :，即{:模板名}，引入子模板 
--list ?，即{? 值1,值2,.... }，模板内缓存，使用多个值确定一个唯一的缓存的名字，如果该缓存存在，则从此行开始到下一个{%end}之前的所有代码都将直接从缓存中取出而无须再次解析
--list ----，即4个-号，{----名字}或{----名字()}，定义分段，从上一个分段结束处或模板开始位置到当前位置的所有模板代码，定义为一个分段。分段在下面有详细的使用说明

--segment 上面的{% }以及{= }是最容易理解的，无非就是直接写Lua代码而已。但是{? }和{----}就需要一番说明了。这里先说{? }即模板缓存。看下来的代码：
--[[
for i = 1, #items do
	<a href="{=items[i].url}">{=items[i].text}</a><br/>
end
--]]
--segment 这是一段很简单的代码，就是循环的输出多个链接，每个链接一行。如果，这个items数组其实是相对比较固定的，比如几种不同类型的用户，每种类型的用户的items才是不一样的。
---这种情况下，如果每一个request都需要将这段代码重新运行一遍，其实效率是非常低下的，而不重新运行一遍，如果两次request的用户类型不同的话怎么办呢？这里就可以用模板缓存来解决
---问题了。使用了模板缓存之后的代码如下 ：
--[[
{? tostring(user.usertype) }
	for i = 1, #items do
		<a href="{=items[i].url}">{=items[i].text}</a><br/>
	end
{% end}
--]]
--segment user.usertype是一个变量值，这个变量的值就像一个标识符，用于标记下面这段直到{% end}处之间的代码，在第一次运行完了之后将被缓存起来，之后再被运行只要user.usertype是一
---样的，那么这中间的值就会直接从缓存中取出而不会再次解析。所以?号后面的值可以有多个，比如{? user.usertype, user.viplevel, ... }，...代表可以有多个，不管多少个，最后都会被
---合并成一个Array型的Table并且被table.concat函数连接成一个字符串。所以这些值是变量也可以，是字符串或值也可以，只要最后能被table.concat函数成功运行连接成一个大字符串就可以了。

--segment 模板缓存之后，下面说一下{----}这种分段的用法，先看一段示例代码：
--[[
<input type="text" id="name" size="20" value="init_value" />
{----html()}

#name {
	border: 1px solid #CCC;
}
{----css}

(function() {
	$('#name')
		.focus(function() {
		})
		.blur(function() {
			// 检测这个名字的输入是否合法
		});
})
{----init}

(function() {
	return $('#name').val().trim();
})
{----get}
--]]
--segment 好了，代码结束，直接的看代码，可能会有点晕，先解释一下。这段代码被{----xxx}分成了4段，第1段是HTML部分，生成了一个input:text控件，第2段是CSS，定义了这个input的一些样式
---（这只是一个展示，不要去纠结代码的实际含义），第3段是一段JS代码，定义了一个匿名函数，对这个input响应了focus和blur事件，第4段是另外一段JS代码，也是一个匿名函数，返回了这个input
---输入的字符串。

--segment 代码说完了，先来说一下这样做的意义。一般的模板库都会支持子模板，子模板的作用就是为了将代码中公共的部分提取出来以便多处相同的地方可以重复的使用。但是很多时候，我们需要的某
---种功能其实也有很大的相似度，但是为了实现出这个功能，需要有HTML代码、CSS代码以及好些JS代码。如果将这些代码分成在多个模板里面，维护起来并不是很舒服。那么将同一个模板需要的各部分代码
---合在一个文件里，可以按代码类型来分（HTML/CSS/JS）也可以按功能来分（如上面提供了两个JS函数），这样使用起来就比较容易了。并且，在这种用法下还可以对名字定义函数调用，如本例中第一段
---代码定义的名字就是html()，名字中有一对空括号，这就表示上面这段代码中有可以被替换的部分，那么他就不再是一个简单的字符串了。下面给出这样一个模板的使用方法：
--[[
<!--引入模板-->
{:query \ name_query_subtemplate}

<head>
<style type="text/css">
// 其它的CSS代码

//引入模板中的CSS代码
{=query.css}
</style>
<script>
$(function() {
	{=query.init}();
});
</script>
</head>

<body>
{=query.html( { init_value = '这个字符串将会替换掉模板中html命名段中的init_value这个字符串' } )}
</body>
--]]
--segment 上面就是使用这段模板的代码，query \ name_query_subtemplate表示引用名为name_query_subtemplate的这个模板，引用之后的名字为query。下面的query.css、query.init等就是将子模板中的
---各段代码引入来使用。query.html还给出了参数，参数中是一个由key=>value组成的table，这个table将被按照key是源字符串，value是目标字符串的对照关系替换掉模板代码解析完之后的字符串。

--segment 最后，再回头说一下模板内缓存。

--segment 模板缓存分为内缓存和全局模板缓存，这两种缓存虽然名字接近但完全是两回事。全局模板缓存是用来缓存整个模板的，因为模板从代码到可以被用于渲染这中间需要经历字符串语法解析、Lua VM的
---load至少和渲染三个过程，而全局模板缓存减掉的是前两个过程，但是对于模板渲染这一步中所需要占用的资源和运行的时间是，全局模板缓存没有任何办法的。也就是说启不启用全局模板缓存，模板的渲染
---时间都是不会变的。那么模板内缓存就可以在某些特定的情况下减少渲染过程中所耗费的时间。

--segment 如何达到呢？就如一开始的那个例子，不管请求量多大，相同类型的用户所看到的链接都是一样的，这样就有了相当大的优化余地。这些相同的部分，只有第一次运行的时候需要真正的渲染一次，然后
---将其缓存起来，之后再运行的时候，就可以直接取出缓存而无须再次渲染，在合适的位置合理的使用这种模板内缓存，效率就会大为提升。