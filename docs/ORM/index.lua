--@type:doc
--name ORM.index
--title ORM总述

--segment ORM即Object Relation Mapping的缩写，意思是数据关系映射，即把数据库的表与字段关系映射成代码可描述的结构关系，在Lua中，即Table。使用ORM可以在一定程度上
---减少甚至不需要再编写SQL语句，因为ORM有了映射关系之后，可以自行帮你完成SQL语句的组建。另外也可以隐藏一些细节操作，可以将对数据的操作包装成函数，多人合作的时候
---其它人员只需要直接调用你写的函数再传入适量的参数即可，无须再去具体的了解相应数据表的详细设计，这样可以避免多人合作代码的Bug和冗余等。所以，尽管使用ORM之后，比
---直接操作数据库的代码运行开销要大了不少，但是合理合适的使用ORM，带来的好处还是非常多的，比如ORM还可以让代码更易读、更清晰，减少随处乱放的让人晕掉的SQL语句等。

--segment ORM在Reeme中的设计理念为“尽量的趋于简单”，这是因为ORM一旦构建得太复杂了，代码的运行效率将会非常低，而在平日里的实际项目中，大多数情况下的数据库操作还是
---相对简单的，复杂的操作相对少，所以简化ORM提升其代码运行效率是第一必要的，一些很复杂的不是非常适合用ORM去做的事情，Reeme的ORM可能就不会提供这样的功能，遇到这种情
---况的时候，就请自行编写SQL语句直接操作数据来完成。换句话说，作为开发者，请正确的看待ORM，不能重度依赖，一切框架和基础库的前提是为了提升工作效率和减少错误发生，同
---时让开发变得更简单，最好还能让代码的运行效率不要下降或反而得到提升。不正确的使用就失去了框架的意义了。

--segment 由于OpenResty的Mysql驱动不够完善，Reeme的ORM在设计的时候也受到了一定的限制，比如但凡所有的查询，都被默认的设置了最多只返回前50条记录的限制，如果想要获取更
---多，必须要手动的设置。但不能去掉限制，因为如果去掉限制的话，在开发机上内存不是很足而记录数量巨大（比如100万条）的时候，CPU或者内存有可能会挂掉…………

--segment 好了，前言就说到这里了。下面要说一下ORM中最重要的基础，这是基础的基础，就是模型的定义。

--segment 模型是面向对向的说法，实际上一个模型就是数据库中的一张表，模型的作用首先就是描述这张表，有哪些字段，这些字段的大体情况，有哪些索引，分别是什么类型的索引，
---以及如何分的组。这个描述对ORM在运行过程中是必须的，没有这些基本信息，ORM无法建立起SQL最终的SQL语句。因此，使用ORM之前，至少要先定义一个模型。

--segment 下面是一个模型定义的范例代码：
--[[
return {
	fields = {
		id = '*i(8)',
		a = 'i(8)0',
		b = "#s(20)''",
		d = 'i(1)0',
		f = "s(65536)''"
	},
	indices = {
		id = 'primary',
	}
}
--]]
--segment 基于这段示例代码，我们可以看到一个模型的定义实际上就是编写一个table定义的代码，并且在代码的最后将其return即可。而这个table中，有一个fields和一个indices的
---两个子table，分别用于定义表中所有的字段以及字段的类型、长度和是否null/auto increament等，而indices则定义了哪个字段是什么类型的索引。关于模型的定义，将在下一篇文档
---[#[定义模型]ORM.defmodel]为您详细说明。
